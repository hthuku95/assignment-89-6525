content='import json\nimport logging\nfrom typing import Dict, Any, Optional\nfrom channels.generic.websocket import AsyncWebsocketConsumer\nfrom channels.db import database_sync_to_async\nfrom django.contrib.auth.models import AnonymousUser\nfrom django.contrib.auth import get_user_model\nfrom django.core.exceptions import ValidationError\nfrom .models import Notification\nfrom .serializers import NotificationSerializer\n\nUser = get_user_model()\nlogger = logging.getLogger(__name__)\n\n\nclass NotificationConsumer(AsyncWebsocketConsumer):\n    """\n    WebSocket consumer for real-time notifications.\n    Handles user-specific notification channels and broadcasts.\n    """\n\n    async def connect(self):\n        """\n        Handle WebSocket connection.\n        Authenticate user and join their personal notification group.\n        """\n        try:\n            # Get user from scope (set by authentication middleware)\n            self.user = self.scope.get("user")\n            \n            if isinstance(self.user, AnonymousUser):\n                logger.warning("Anonymous user attempted to connect to notifications")\n                await self.close(code=4001)\n                return\n\n            # Create user-specific group name\n            self.group_name = f"notifications_{self.user.id}"\n            \n            # Join user\'s notification group\n            await self.channel_layer.group_add(\n                self.group_name,\n                self.channel_name\n            )\n            \n            # Accept the WebSocket connection\n            await self.accept()\n            \n            # Send initial connection confirmation\n            await self.send(text_data=json.dumps({\n                \'type\': \'connection_established\',\n                \'message\': \'Connected to notifications\',\n                \'user_id\': self.user.id\n            }))\n            \n            # Send unread notifications count\n            unread_count = await self.get_unread_count()\n            await self.send(text_data=json.dumps({\n                \'type\': \'unread_count\',\n                \'count\': unread_count\n            }))\n            \n            logger.info(f"User {self.user.id} connected to notifications")\n            \n        except Exception as e:\n            logger.error(f"Error in notification consumer connect: {str(e)}")\n            await self.close(code=4000)\n\n    async def disconnect(self, close_code):\n        """\n        Handle WebSocket disconnection.\n        Leave the user\'s notification group.\n        """\n        try:\n            if hasattr(self, \'group_name\'):\n                await self.channel_layer.group_discard(\n                    self.group_name,\n                    self.channel_name\n                )\n            \n            if hasattr(self, \'user\') and self.user.is_authenticated:\n                logger.info(f"User {self.user.id} disconnected from notifications")\n                \n        except Exception as e:\n            logger.error(f"Error in notification consumer disconnect: {str(e)}")\n\n    async def receive(self, text_data):\n        """\n        Handle incoming WebSocket messages from client.\n        Process notification-related actions like marking as read.\n        """\n        try:\n            data = json.loads(text_data)\n            message_type = data.get(\'type\')\n            \n            if message_type == \'mark_as_read\':\n                await self.mark_notification_as_read(data.get(\'notification_id\'))\n            elif message_type == \'mark_all_as_read\':\n                await self.mark_all_notifications_as_read()\n            elif message_type == \'get_notifications\':\n                await self.send_recent_notifications(data.get(\'limit\', 10))\n            elif message_type == \'ping\':\n                await self.send(text_data=json.dumps({\'type\': \'pong\'}))\n            else:\n                logger.warning(f"Unknown message type: {message_type}")\n                \n        except json.JSONDecodeError:\n            logger.error("Invalid JSON received in notification consumer")\n            await self.send(text_data=json.dumps({\n                \'type\': \'error\',\n                \'message\': \'Invalid JSON format\'\n            }))\n        except Exception as e:\n            logger.error(f"Error processing notification message: {str(e)}")\n            await self.' additional_kwargs={} response_metadata={'id': 'msg_01CqYmt1xC781zvHVySmkeTm', 'model': 'claude-sonnet-4-20250514', 'stop_reason': 'max_tokens', 'stop_sequence': None, 'usage': {'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0, 'input_tokens': 405, 'output_tokens': 1024, 'service_tier': 'standard'}} id='run--31e80df9-216b-4a57-8331-2e9b94e8c0aa-0' usage_metadata={'input_tokens': 405, 'output_tokens': 1024, 'total_tokens': 1429, 'input_token_details': {'cache_read': 0, 'cache_creation': 0}}